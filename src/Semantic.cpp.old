#include "Semantic.hpp"

namespace C {

std::pair<ResolvedDecl *, int> Sema::lookup_decl(const std::string_view id) {
    int scopeIdx = 0;
    for (auto it = m_scopes.rbegin(); it != m_scopes.rend(); ++it) {
        for (auto &decl : *it) {
            if (decl->identifier != id) continue;

            return {decl.get(), scopeIdx};
        }

        ++scopeIdx;
    }
    return {nullptr, -1};
}

bool Sema::insert_decl_to_current_scope(ResolvedDecl &decl) {
    const auto &[foundDecl, scopeIdx] = lookup_decl(decl.identifier);

    if (foundDecl && scopeIdx == 0) {
        report(decl.location, "redeclaration of '" + std::string(decl.identifier) + '\'');
        return false;
    }

    m_scopes.back().emplace_back(&decl);
    return true;
}

std::vector<std::unique_ptr<ResolvedDecl>> Sema::resolve_ast() {
    ScopeRAII globalScope(*this);
    std::vector<std::unique_ptr<ResolvedDecl>> resolvedTree;

    bool error = false;
    std::vector<const FunctionDecl *> functionsToResolve;

    // Resolve every struct first so that functions have access to them in their
    // signature.
    for (auto &decl : m_ast) {
        if (const auto *fn = dynamic_cast<const FunctionDecl *>(decl.get())) {
            functionsToResolve.emplace_back(fn);
            continue;
        }

        llvm_unreachable("unexpected declaration");
    }

    if (error) return {};

    // Insert println first to be able to detect a possible redeclaration.
    auto *printlnDecl = resolvedTree.emplace_back(create_builtin_println()).get();
    insert_decl_to_current_scope(*printlnDecl);

    for (auto &fn : functionsToResolve) {
        if (auto resolvedDecl = resolve_function_declaration(*fn);
            resolvedDecl && insert_decl_to_current_scope(*resolvedDecl)) {
            resolvedTree.emplace_back(std::move(resolvedDecl));
            continue;
        }

        error = true;
    }

    if (error) return {};

    auto nextFunctionDecl = functionsToResolve.begin();
    for (auto &currentDecl : resolvedTree) {
        if (auto *fn = dynamic_cast<ResolvedFunctionDecl *>(currentDecl.get())) {
            if (fn == printlnDecl) continue;

            ScopeRAII paramScope(*this);
            for (auto &param : fn->params) insert_decl_to_current_scope(*param);

            currentFunction = fn;
            if (auto resolvedBody = resolve_block(*(*nextFunctionDecl++)->body)) {
                fn->body = std::move(resolvedBody);
                // error |= runFlowSensitiveChecks(*fn);
                continue;
            }
            error = true;
        }
    }

    if (error) return {};

    return resolvedTree;
}

std::unique_ptr<ResolvedFunctionDecl> Sema::create_builtin_println() {
    SourceLocation loc{"<builtin>", 0, 0};

    auto param = std::make_unique<ResolvedParamDecl>(loc, "n", Type::builtinInt());

    std::vector<std::unique_ptr<ResolvedParamDecl>> params;
    params.emplace_back(std::move(param));

    auto block = std::make_unique<ResolvedBlock>(loc, std::vector<std::unique_ptr<ResolvedStmt>>());

    return std::make_unique<ResolvedFunctionDecl>(loc, "println", Type::builtinVoid(), std::move(params),
                                                  std::move(block));
}

// std::vector<std::unique_ptr<ResolvedFunctionDecl>> Sema::resolve_source_file() {
//     for (size_t i = 1; i < resolvedTree.size(); ++i) {
//         currentFunction = resolvedTree[i].get();

//         ScopeRAII paramScope(this);
//         for (auto &&param : currentFunction->params) insertDeclToCurrentScope(*param);
//         auto resolvedBody = resolveBlock(*ast[i - 1]->body);
//         if (!resolvedBody) {
//             error = true;
//             continue;
//         }

//         currentFunction->body = std::move(resolvedBody);
//     }
//     if (error) return {};

//     return resolvedTree;
// }

std::optional<Type> Sema::resolve_type(Type parsedType) {
    if (parsedType.kind == Type::Kind::Custom) return std::nullopt;

    return parsedType;
}

std::unique_ptr<ResolvedFunctionDecl> Sema::resolve_function_declaration(const FunctionDecl &function) {
    std::optional<Type> type = resolve_type(function.type);

    if (!type) {
        return report(function.location, "function '" + std::string(function.identifier) + "' has invalid '" +
                                             function.type.name + "' type");
    }

    if (function.identifier == "main") {
        if (type->kind != Type::Kind::Void)
            return report(function.location, "'main' function is expected to have 'void' type");

        if (!function.params.empty())
            return report(function.location, "'main' function is expected to take no arguments");
    }

    std::vector<std::unique_ptr<ResolvedParamDecl>> resolvedParams;

    ScopeRAII paramScope(*this);
    for (auto &param : function.params) {
        auto resolvedParam = resolve_param_decl(*param);

        if (!resolvedParam || !insert_decl_to_current_scope(*resolvedParam)) return nullptr;

        resolvedParams.emplace_back(std::move(resolvedParam));
    }
    return std::make_unique<ResolvedFunctionDecl>(function.location, function.identifier, *type,
                                                  std::move(resolvedParams), nullptr);
}

std::unique_ptr<ResolvedParamDecl> Sema::resolve_param_decl(const ParamDecl &param) {
    std::optional<Type> type = resolve_type(param.type);

    if (!type || type->kind == Type::Kind::Void)
        return report(param.location,
                      "parameter '" + std::string(param.identifier) + "' has invalid '" + param.type.name + "' type");

    return std::make_unique<ResolvedParamDecl>(param.location, param.identifier, *type);
}

std::unique_ptr<ResolvedBlock> Sema::resolve_block(const Block &block) {
    std::vector<std::unique_ptr<ResolvedStmt>> resolvedStatements;

    bool error = false;
    int reportUnreachableCount = 0;

    ScopeRAII blockScope(*this);
    for (auto &stmt : block.statements) {
        auto resolvedStmt = resolve_stmt(*stmt);

        error |= !resolvedStatements.emplace_back(std::move(resolvedStmt));
        if (error) continue;
        if (reportUnreachableCount == 1) {
            report(stmt->location, "unreachable statement", true);
            ++reportUnreachableCount;
        }

        if (dynamic_cast<ReturnStmt *>(stmt.get())) ++reportUnreachableCount;
    }
    if (error) return nullptr;

    return std::make_unique<ResolvedBlock>(block.location, std::move(resolvedStatements));
}

std::unique_ptr<ResolvedStmt> Sema::resolve_stmt(const Statement &stmt) {
    if (auto *expr = dynamic_cast<const Expr *>(&stmt)) return resolve_expr(*expr);

    if (auto *returnStmt = dynamic_cast<const ReturnStmt *>(&stmt)) return resolve_return_stmt(*returnStmt);

    llvm_unreachable("unexpected statement");
}

std::unique_ptr<ResolvedReturnStmt> Sema::resolve_return_stmt(const ReturnStmt &returnStmt) {
    if (currentFunction->type.kind == Type::Kind::Void && returnStmt.expr)
        return report(returnStmt.location, "unexpected return value in void function");

    if (currentFunction->type.kind != Type::Kind::Void && !returnStmt.expr)
        return report(returnStmt.location, "expected a return value");

    std::unique_ptr<ResolvedExpr> resolvedExpr;
    if (returnStmt.expr) {
        resolvedExpr = resolve_expr(*returnStmt.expr);
        if (!resolvedExpr) return nullptr;

        if (currentFunction->type.kind != resolvedExpr->type.kind)
            return report(resolvedExpr->location, "unexpected return type");
    }

    return std::make_unique<ResolvedReturnStmt>(returnStmt.location, std::move(resolvedExpr));
}

std::unique_ptr<ResolvedExpr> Sema::resolve_expr(const Expr &expr) {
    if (const auto *number = dynamic_cast<const NumberLiteral *>(&expr))
        return std::make_unique<ResolvedNumberLiteral>(number->location, std::stod(std::string(number->value)));

    if (const auto *declRefExpr = dynamic_cast<const DeclRefExpr *>(&expr)) return resolve_decl_ref_expr(*declRefExpr);

    llvm_unreachable("unexpected expression");
}

std::unique_ptr<ResolvedDeclRefExpr> Sema::resolve_decl_ref_expr(const DeclRefExpr &declRefExpr, bool isCallee) {
    auto decl = lookup_decl(declRefExpr.identifier).first;
    if (!decl) return report(declRefExpr.location, "symbol '" + std::string(declRefExpr.identifier) + "' not found");

    // TODO: check segfault
    // if (!isCallee && dynamic_cast<ResolvedFunctionDecl *>(decl))
    //     return report(declRefExpr.location, "expected to call function '" + std::string(declRefExpr.identifier) + "'");

    return std::make_unique<ResolvedDeclRefExpr>(declRefExpr.location, *decl);
}

std::unique_ptr<ResolvedCallExpr> Sema::resolve_call_expr(const CallExpr &call) {
    const auto *dre = dynamic_cast<const DeclRefExpr *>(call.callee.get());

    if (!dre) return report(call.location, "expression cannot be called as a function");

    varOrReturn(resolvedCallee, resolve_decl_ref_expr(*dre, true));

    const auto *resolvedFunctionDecl = dynamic_cast<const ResolvedFunctionDecl *>(&resolvedCallee->decl);

    if (!resolvedFunctionDecl) return report(call.location, "calling non-function symbol");

    if (call.arguments.size() != resolvedFunctionDecl->params.size())
        return report(call.location, "argument count mismatch in function call");

    std::vector<std::unique_ptr<ResolvedExpr>> resolvedArguments;
    int idx = 0;
    for (auto &arg : call.arguments) {
        varOrReturn(resolvedArg, resolve_expr(*arg));

        if (resolvedArg->type.kind != resolvedFunctionDecl->params[idx]->type.kind)
            return report(resolvedArg->location, "unexpected type of argument");

        ++idx;
        resolvedArguments.emplace_back(std::move(resolvedArg));
    }

    return std::make_unique<ResolvedCallExpr>(call.location, *resolvedFunctionDecl, std::move(resolvedArguments));
}
}  // namespace C
