// RUN: compiler %s -llvm-dump 2>&1 | filecheck %s
// RUN: diff <(compiler %s -run 2>&1) <(echo -n -e '10\n10\n20\n20\nColor{1,1,1}\nColor{10,10,10}\n')

struct Color {
    r: i32,
    g: i32,
    b: i32,
}

fn bar(c: *Color) -> void {
    c.r = 10;
    c.g = 10;
    c.b = 10;
}
// CHECK: define void @bar(ptr byref(%Color) %c) {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %0 = getelementptr inbounds %Color, ptr %c, i32 0, i32 0
// CHECK-NEXT:   store i32 10, ptr %0, align 4
// CHECK-NEXT:   %1 = getelementptr inbounds %Color, ptr %c, i32 0, i32 1
// CHECK-NEXT:   store i32 10, ptr %1, align 4
// CHECK-NEXT:   %2 = getelementptr inbounds %Color, ptr %c, i32 0, i32 2
// CHECK-NEXT:   store i32 10, ptr %2, align 4
// CHECK-NEXT:   ret void
// CHECK-NEXT: }

fn printColor(c: *Color) -> void {
    dprintf(1, "Color{%d,%d,%d}\n", c.r, c.g, c.b);
}
// CHECK: define void @printColor(ptr byref(%Color) %c) {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %0 = getelementptr inbounds %Color, ptr %c, i32 0, i32 0
// CHECK-NEXT:   %1 = load i32, ptr %0, align 4
// CHECK-NEXT:   %2 = getelementptr inbounds %Color, ptr %c, i32 0, i32 1
// CHECK-NEXT:   %3 = load i32, ptr %2, align 4
// CHECK-NEXT:   %4 = getelementptr inbounds %Color, ptr %c, i32 0, i32 2
// CHECK-NEXT:   %5 = load i32, ptr %4, align 4
// CHECK-NEXT:   %6 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str, i32 %1, i32 %3, i32 %5)
// CHECK-NEXT:   ret void
// CHECK-NEXT: }

fn foo(x: *i32) -> void {
    dprintf(1, "%d\n", *x);
    *x = 20;
    dprintf(1, "%d\n", *x);
}
// CHECK: define void @foo(ptr byref(i32) %x) {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %0 = load i32, ptr %x, align 4
// CHECK-NEXT:   %1 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str.1, i32 %0)
// CHECK-NEXT:   store i32 20, ptr %x, align 4
// CHECK-NEXT:   %2 = load i32, ptr %x, align 4
// CHECK-NEXT:   %3 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str.2, i32 %2)
// CHECK-NEXT:   ret void
// CHECK-NEXT: }

extern fn dprintf(fd:i32, fmt:*u8, ...) -> i32;
extern fn exit(code:i32) -> void;

fn main() -> void {
    let i = 10;
    let i_ptr:*i32 = &i;
    dprintf(1, "%d\n", i);
    foo(i_ptr);
    dprintf(1, "%d\n", *i_ptr);

    let col = Color{r:1, g:1, b:1};
    let col_ptr:*Color = &col;
    printColor(&col);
    bar(col_ptr);
    printColor(col_ptr);
}
// CHECK: define void @__builtin_main() {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %i = alloca i32, align 4
// CHECK-NEXT:   %i_ptr = alloca ptr, align 8
// CHECK-NEXT:   %col = alloca %Color, align 8
// CHECK-NEXT:   %tmp.struct.Color = alloca %Color, align 8
// CHECK-NEXT:   %col_ptr = alloca ptr, align 8
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %i, i8 0, i64 4, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %i_ptr, i8 0, i64 8, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %col, i8 0, i64 12, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %tmp.struct.Color, i8 0, i64 12, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %col_ptr, i8 0, i64 8, i1 false)
// CHECK-NEXT:   store i32 10, ptr %i, align 4
// CHECK-NEXT:   store ptr %i, ptr %i_ptr, align 8
// CHECK-NEXT:   %0 = load i32, ptr %i, align 4
// CHECK-NEXT:   %1 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str.3, i32 %0)
// CHECK-NEXT:   %2 = load ptr, ptr %i_ptr, align 8
// CHECK-NEXT:   call void @foo(ptr byref(i32) %2)
// CHECK-NEXT:   %3 = load ptr, ptr %i_ptr, align 8
// CHECK-NEXT:   %4 = load i32, ptr %3, align 4
// CHECK-NEXT:   %5 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str.4, i32 %4)
// CHECK-NEXT:   %6 = getelementptr inbounds %Color, ptr %tmp.struct.Color, i32 0, i32 0
// CHECK-NEXT:   store i32 1, ptr %6, align 4
// CHECK-NEXT:   %7 = getelementptr inbounds %Color, ptr %tmp.struct.Color, i32 0, i32 1
// CHECK-NEXT:   store i32 1, ptr %7, align 4
// CHECK-NEXT:   %8 = getelementptr inbounds %Color, ptr %tmp.struct.Color, i32 0, i32 2
// CHECK-NEXT:   store i32 1, ptr %8, align 4
// CHECK-NEXT:   call void @llvm.memcpy.p0.p0.i64(ptr align 4 %col, ptr align 4 %tmp.struct.Color, i64 12, i1 false)
// CHECK-NEXT:   store ptr %col, ptr %col_ptr, align 8
// CHECK-NEXT:   call void @printColor(ptr byref(%Color) %col)
// CHECK-NEXT:   %9 = load ptr, ptr %col_ptr, align 8
// CHECK-NEXT:   call void @bar(ptr byref(%Color) %9)
// CHECK-NEXT:   %10 = load ptr, ptr %col_ptr, align 8
// CHECK-NEXT:   call void @printColor(ptr byref(%Color) %10)
// CHECK-NEXT:   ret void
// CHECK-NEXT: }