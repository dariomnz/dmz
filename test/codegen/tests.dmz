// RUN: dmz %s -I std %S/../../std/std.dmz -llvm-dump -test -module 2>&1 | filecheck %s
// RUN: diff <(dmz %s -I std %S/../../std/std.dmz -run -test -module 2>&1) <(echo -n -e 'All 2 tests passed.\n')
const std = import("std");

fn add(x: i32, y: i32) -> i32 {
    return x + y;
}

test "add test 2" {
    try std.testing.expect(add(1, 1) == 2);
    try std.testing.expect(add(-1, 3) == 2);
}

test "add test 3" {
    try std.testing.expect(add(2, 1) == 3);
    try std.testing.expect(add(2, 2) == 4);
    try std.testing.expect(add(1, add(1, 1)) == 3);
}

// CHECK: define i32 @"std.builtin.@builtin_test_num"() {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %retval = alloca i32, align 4
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %retval, i8 0, i64 4, i1 false)
// CHECK-NEXT:   store i32 2, ptr %retval, align 4
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: return:                                           ; preds = %entry
// CHECK-NEXT:   %0 = load i32, ptr %retval, align 4
// CHECK-NEXT:   ret i32 %0
// CHECK-NEXT: }
// CHECK-NEXT: 
// CHECK-NEXT: define void @"std.builtin.@builtin_test_run"(ptr sret(%error.struct.void) %ret, i32 %n) {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %struct.ret.tmp = alloca %error.struct.void, align 8
// CHECK-NEXT:   %struct.ret.tmp2 = alloca %error.struct.void, align 8
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp2, i8 0, i64 16, i1 false)
// CHECK-NEXT:   switch i32 %n, label %switch.else [
// CHECK-NEXT:     i32 0, label %switch.case
// CHECK-NEXT:     i32 1, label %switch.case1
// CHECK-NEXT:   ]
// CHECK-NEXT: 
// CHECK-NEXT: switch.case:                                      ; preds = %entry
// CHECK-NEXT:   call void @"tests.add test 2"(ptr sret(%error.struct.void) %struct.ret.tmp)
// CHECK-NEXT:   %0 = getelementptr inbounds nuw %error.struct.void, ptr %struct.ret.tmp, i32 0, i32 1
// CHECK-NEXT:   %1 = load ptr, ptr %0, align 8
// CHECK-NEXT:   %2 = ptrtoint ptr %1 to i64
// CHECK-NEXT:   %ptr.to.bool = icmp ne i64 %2, 0
// CHECK-NEXT:   br i1 %ptr.to.bool, label %if.true.try, label %if.exit.try
// CHECK-NEXT: 
// CHECK-NEXT: if.true.try:                                      ; preds = %switch.case
// CHECK-NEXT:   %3 = getelementptr inbounds nuw %error.struct.void, ptr %ret, i32 0, i32 1
// CHECK-NEXT:   store ptr %1, ptr %3, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.try:                                      ; preds = %switch.case
// CHECK-NEXT:   br label %switch.exit
// CHECK-NEXT: 
// CHECK-NEXT: switch.case1:                                     ; preds = %entry
// CHECK-NEXT:   call void @"tests.add test 3"(ptr sret(%error.struct.void) %struct.ret.tmp2)
// CHECK-NEXT:   %4 = getelementptr inbounds nuw %error.struct.void, ptr %struct.ret.tmp2, i32 0, i32 1
// CHECK-NEXT:   %5 = load ptr, ptr %4, align 8
// CHECK-NEXT:   %6 = ptrtoint ptr %5 to i64
// CHECK-NEXT:   %ptr.to.bool3 = icmp ne i64 %6, 0
// CHECK-NEXT:   br i1 %ptr.to.bool3, label %if.true.try4, label %if.exit.try5
// CHECK-NEXT: 
// CHECK-NEXT: if.true.try4:                                     ; preds = %switch.case1
// CHECK-NEXT:   %7 = getelementptr inbounds nuw %error.struct.void, ptr %ret, i32 0, i32 1
// CHECK-NEXT:   store ptr %5, ptr %7, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.try5:                                     ; preds = %switch.case1
// CHECK-NEXT:   br label %switch.exit
// CHECK-NEXT: 
// CHECK-NEXT: switch.else:                                      ; preds = %entry
// CHECK-NEXT:   br label %switch.exit
// CHECK-NEXT: 
// CHECK-NEXT: switch.exit:                                      ; preds = %switch.else, %if.exit.try5, %if.exit.try
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: return:                                           ; preds = %switch.exit, %if.true.try4, %if.true.try
// CHECK-NEXT:   ret void
// CHECK-NEXT: }

// CHECK: define ptr @"std.builtin.@builtin_test_name"(i32 %n) {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %retval = alloca ptr, align 8
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %retval, i8 0, i64 8, i1 false)
// CHECK-NEXT:   switch i32 %n, label %switch.else [
// CHECK-NEXT:     i32 0, label %switch.case
// CHECK-NEXT:     i32 1, label %switch.case1
// CHECK-NEXT:   ]
// CHECK-NEXT: 
// CHECK-NEXT: switch.case:                                      ; preds = %entry
// CHECK-NEXT:   store ptr @global.str, ptr %retval, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: switch.case1:                                     ; preds = %entry
// CHECK-NEXT:   store ptr @global.str.1, ptr %retval, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: switch.else:                                      ; preds = %entry
// CHECK-NEXT:   store ptr @global.str.2, ptr %retval, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: switch.exit:                                      ; No predecessors!
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: return:                                           ; preds = %switch.exit, %switch.else, %switch.case1, %switch.case
// CHECK-NEXT:   %0 = load ptr, ptr %retval, align 8
// CHECK-NEXT:   ret ptr %0
// CHECK-NEXT: }

// CHECK: define void @__builtin_main_test() {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %num_test = alloca i32, align 4
// CHECK-NEXT:   %result = alloca i32, align 4
// CHECK-NEXT:   %for.counter = alloca i64, align 8
// CHECK-NEXT:   %for.capture.i = alloca i64, align 8
// CHECK-NEXT:   %test_name = alloca ptr, align 8
// CHECK-NEXT:   %err = alloca ptr, align 8
// CHECK-NEXT:   %struct.ret.tmp = alloca %error.struct.void, align 8
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %num_test, i8 0, i64 4, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %result, i8 0, i64 4, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %for.counter, i8 0, i64 8, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %for.capture.i, i8 0, i64 8, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %test_name, i8 0, i64 8, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %err, i8 0, i64 8, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp, i8 0, i64 16, i1 false)
// CHECK-NEXT:   %0 = call i32 @"std.builtin.@builtin_test_num"()
// CHECK-NEXT:   store i32 %0, ptr %num_test, align 4
// CHECK-NEXT:   store i32 0, ptr %result, align 4
// CHECK-NEXT:   store i64 0, ptr %for.capture.i, align 4
// CHECK-NEXT:   %1 = load i32, ptr %num_test, align 4
// CHECK-NEXT:   %int.to.int = sext i32 %1 to i64
// CHECK-NEXT:   %2 = sub i64 %int.to.int, 0
// CHECK-NEXT:   br label %for.cond
// CHECK-NEXT: 
// CHECK-NEXT: for.cond:                                         ; preds = %for.increment, %entry
// CHECK-NEXT:   %3 = load i64, ptr %for.counter, align 4
// CHECK-NEXT:   %4 = icmp slt i64 %3, %2
// CHECK-NEXT:   br i1 %4, label %for.body, label %for.exit
// CHECK-NEXT: 
// CHECK-NEXT: for.increment:                                    ; preds = %if.exit
// CHECK-NEXT:   %5 = load i64, ptr %for.counter, align 4
// CHECK-NEXT:   %6 = add i64 %5, 1
// CHECK-NEXT:   store i64 %6, ptr %for.counter, align 4
// CHECK-NEXT:   %7 = load i64, ptr %for.capture.i, align 4
// CHECK-NEXT:   %8 = add i64 %7, 1
// CHECK-NEXT:   store i64 %8, ptr %for.capture.i, align 4
// CHECK-NEXT:   br label %for.cond
// CHECK-NEXT: 
// CHECK-NEXT: for.body:                                         ; preds = %for.cond
// CHECK-NEXT:   %9 = load i32, ptr %result, align 4
// CHECK-NEXT:   %10 = add i32 %9, 1
// CHECK-NEXT:   store i32 %10, ptr %result, align 4
// CHECK-NEXT:   %11 = load i64, ptr %for.capture.i, align 4
// CHECK-NEXT:   %12 = call ptr @"std.builtin.@builtin_test_name"(i64 %11)
// CHECK-NEXT:   store ptr %12, ptr %test_name, align 8
// CHECK-NEXT:   %13 = load i64, ptr %for.capture.i, align 4
// CHECK-NEXT:   call void @"std.builtin.@builtin_test_run"(ptr sret(%error.struct.void) %struct.ret.tmp, i64 %13)
// CHECK-NEXT:   %14 = getelementptr inbounds nuw %error.struct.void, ptr %struct.ret.tmp, i32 0, i32 1
// CHECK-NEXT:   %15 = load ptr, ptr %14, align 8
// CHECK-NEXT:   store ptr %15, ptr %err, align 8
// CHECK-NEXT:   %16 = load ptr, ptr %err, align 8
// CHECK-NEXT:   %17 = ptrtoint ptr %16 to i64
// CHECK-NEXT:   %ptr.to.bool = icmp ne i64 %17, 0
// CHECK-NEXT:   br i1 %ptr.to.bool, label %if.true, label %if.exit
// CHECK-NEXT: 
// CHECK-NEXT: for.exit:                                         ; preds = %for.cond
// CHECK-NEXT:   %18 = load i32, ptr %result, align 4
// CHECK-NEXT:   %19 = load i32, ptr %num_test, align 4
// CHECK-NEXT:   %20 = icmp eq i32 %18, %19
// CHECK-NEXT:   br i1 %20, label %if.true1, label %if.false
// CHECK-NEXT: 
// CHECK-NEXT: if.true:                                          ; preds = %for.body
// CHECK-NEXT:   %21 = load i64, ptr %for.capture.i, align 4
// CHECK-NEXT:   %22 = add i64 %21, 1
// CHECK-NEXT:   %23 = load i32, ptr %num_test, align 4
// CHECK-NEXT:   %24 = load ptr, ptr %test_name, align 8
// CHECK-NEXT:   %25 = load ptr, ptr %err, align 8
// CHECK-NEXT:   %26 = call i32 (ptr, ...) @printf(ptr byref(i8) @global.str.3, i64 %22, i32 %23, ptr %24, ptr %25)
// CHECK-NEXT:   %27 = load i32, ptr %result, align 4
// CHECK-NEXT:   %28 = sub i32 %27, 1
// CHECK-NEXT:   store i32 %28, ptr %result, align 4
// CHECK-NEXT:   br label %if.exit
// CHECK-NEXT: 
// CHECK-NEXT: if.exit:                                          ; preds = %if.true, %for.body
// CHECK-NEXT:   br label %for.increment
// CHECK-NEXT: 
// CHECK-NEXT: if.true1:                                         ; preds = %for.exit
// CHECK-NEXT:   %29 = load i32, ptr %num_test, align 4
// CHECK-NEXT:   %30 = call i32 (ptr, ...) @printf(ptr byref(i8) @global.str.4, i32 %29)
// CHECK-NEXT:   br label %if.exit2
// CHECK-NEXT: 
// CHECK-NEXT: if.false:                                         ; preds = %for.exit
// CHECK-NEXT:   %31 = load i32, ptr %result, align 4
// CHECK-NEXT:   %32 = load i32, ptr %num_test, align 4
// CHECK-NEXT:   %33 = load i32, ptr %result, align 4
// CHECK-NEXT:   %34 = sub i32 %32, %33
// CHECK-NEXT:   %35 = call i32 (ptr, ...) @printf(ptr byref(i8) @global.str.5, i32 %31, i32 %34)
// CHECK-NEXT:   br label %if.exit2
// CHECK-NEXT: 
// CHECK-NEXT: if.exit2:                                         ; preds = %if.false, %if.true1
// CHECK-NEXT:   ret void
// CHECK-NEXT: }