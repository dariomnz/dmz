// RUN: compiler %s -I %S/../../std -llvm-dump -test -module 2>&1 | filecheck %s
// RUN: diff <(compiler %s -I %S/../../std -run -test -module 2>&1) <(echo -n -e 'All 2 tests passed.\n')
const std = import("std");

fn add(x:i32, y:i32) -> i32 {
    return x + y;
}

test "add test 2" {
    try std.testing.expect(add(1, 1) == 2);
    try std.testing.expect(add(-1, 3) == 2);
}

test "add test 3" {
    try std.testing.expect(add(2, 1) == 3);
    try std.testing.expect(add(2, 2) == 4);
    try std.testing.expect(add(1, add(1, 1)) == 3);
}

// CHECK: define i32 @"std.builtin.@builtin_test_num"() {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %retval = alloca i32, align 4
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %retval, i8 0, i64 4, i1 false)
// CHECK-NEXT:   store i32 2, ptr %retval, align 4
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: return:                                           ; preds = %entry
// CHECK-NEXT:   %0 = load i32, ptr %retval, align 4
// CHECK-NEXT:   ret i32 %0
// CHECK-NEXT: }
// CHECK-NEXT: 
// CHECK-NEXT: define void @"std.builtin.@builtin_test_run"(ptr sret(%error.struct.void) %ret, i32 %n) {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %struct.ret.tmp = alloca %error.struct.void, align 8
// CHECK-NEXT:   %struct.ret.tmp2 = alloca %error.struct.void, align 8
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp2, i8 0, i64 16, i1 false)
// CHECK-NEXT:   switch i32 %n, label %switch.else [
// CHECK-NEXT:     i32 0, label %switch.case
// CHECK-NEXT:     i32 1, label %switch.case1
// CHECK-NEXT:   ]
// CHECK-NEXT: 
// CHECK-NEXT: switch.case:                                      ; preds = %entry
// CHECK-NEXT:   call void @"add test 2"(ptr sret(%error.struct.void) %struct.ret.tmp)
// CHECK-NEXT:   %0 = getelementptr inbounds %error.struct.void, ptr %struct.ret.tmp, i32 0, i32 1
// CHECK-NEXT:   %1 = load ptr, ptr %0, align 8
// CHECK-NEXT:   %2 = ptrtoint ptr %1 to i64
// CHECK-NEXT:   %ptr.to.bool = icmp ne i64 %2, 0
// CHECK-NEXT:   br i1 %ptr.to.bool, label %if.true.try, label %if.exit.try
// CHECK-NEXT: 
// CHECK-NEXT: if.true.try:                                      ; preds = %switch.case
// CHECK-NEXT:   %3 = getelementptr inbounds %error.struct.void, ptr %ret, i32 0, i32 1
// CHECK-NEXT:   store ptr %1, ptr %3, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.try:                                      ; preds = %switch.case
// CHECK-NEXT:   br label %switch.exit
// CHECK-NEXT: 
// CHECK-NEXT: switch.case1:                                     ; preds = %entry
// CHECK-NEXT:   call void @"add test 3"(ptr sret(%error.struct.void) %struct.ret.tmp2)
// CHECK-NEXT:   %4 = getelementptr inbounds %error.struct.void, ptr %struct.ret.tmp2, i32 0, i32 1
// CHECK-NEXT:   %5 = load ptr, ptr %4, align 8
// CHECK-NEXT:   %6 = ptrtoint ptr %5 to i64
// CHECK-NEXT:   %ptr.to.bool3 = icmp ne i64 %6, 0
// CHECK-NEXT:   br i1 %ptr.to.bool3, label %if.true.try4, label %if.exit.try5
// CHECK-NEXT: 
// CHECK-NEXT: if.true.try4:                                     ; preds = %switch.case1
// CHECK-NEXT:   %7 = getelementptr inbounds %error.struct.void, ptr %ret, i32 0, i32 1
// CHECK-NEXT:   store ptr %5, ptr %7, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.try5:                                     ; preds = %switch.case1
// CHECK-NEXT:   br label %switch.exit
// CHECK-NEXT: 
// CHECK-NEXT: switch.else:                                      ; preds = %entry
// CHECK-NEXT:   br label %switch.exit
// CHECK-NEXT: 
// CHECK-NEXT: switch.exit:                                      ; preds = %switch.else, %if.exit.try5, %if.exit.try
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: return:                                           ; preds = %switch.exit, %if.true.try4, %if.true.try
// CHECK-NEXT:   ret void
// CHECK-NEXT: }

// CHECK: define ptr @"std.builtin.@builtin_test_name"(i32 %n) {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %retval = alloca ptr, align 8
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %retval, i8 0, i64 8, i1 false)
// CHECK-NEXT:   switch i32 %n, label %switch.else [
// CHECK-NEXT:     i32 0, label %switch.case
// CHECK-NEXT:     i32 1, label %switch.case1
// CHECK-NEXT:   ]
// CHECK-NEXT: 
// CHECK-NEXT: switch.case:                                      ; preds = %entry
// CHECK-NEXT:   store ptr @global.str, ptr %retval, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: switch.case1:                                     ; preds = %entry
// CHECK-NEXT:   store ptr @global.str.1, ptr %retval, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: switch.else:                                      ; preds = %entry
// CHECK-NEXT:   store ptr @global.str.2, ptr %retval, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: switch.exit:                                      ; No predecessors!
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: return:                                           ; preds = %switch.exit, %switch.else, %switch.case1, %switch.case
// CHECK-NEXT:   %0 = load ptr, ptr %retval, align 8
// CHECK-NEXT:   ret ptr %0
// CHECK-NEXT: }

// CHECK: define void @__builtin_main_test() {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %num_test = alloca i32, align 4
// CHECK-NEXT:   %result = alloca i32, align 4
// CHECK-NEXT:   %i = alloca i32, align 4
// CHECK-NEXT:   %test_name = alloca ptr, align 8
// CHECK-NEXT:   %struct.ret.tmp = alloca %error.struct.void, align 8
// CHECK-NEXT:   %err = alloca ptr, align 8
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %num_test, i8 0, i64 4, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %result, i8 0, i64 4, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %i, i8 0, i64 4, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %test_name, i8 0, i64 8, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %err, i8 0, i64 8, i1 false)
// CHECK-NEXT:   %0 = call i32 @"std.builtin.@builtin_test_num"()
// CHECK-NEXT:   store i32 %0, ptr %num_test, align 4
// CHECK-NEXT:   store i32 0, ptr %result, align 4
// CHECK-NEXT:   store i32 0, ptr %i, align 4
// CHECK-NEXT:   br label %while.cond
// CHECK-NEXT: 
// CHECK-NEXT: while.cond:                                       ; preds = %if.exit, %entry
// CHECK-NEXT:   %1 = load i32, ptr %i, align 4
// CHECK-NEXT:   %2 = load i32, ptr %num_test, align 4
// CHECK-NEXT:   %3 = icmp slt i32 %1, %2
// CHECK-NEXT:   br i1 %3, label %while.body, label %while.exit
// CHECK-NEXT: 
// CHECK-NEXT: while.body:                                       ; preds = %while.cond
// CHECK-NEXT:   %4 = load i32, ptr %result, align 4
// CHECK-NEXT:   %5 = add i32 %4, 1
// CHECK-NEXT:   store i32 %5, ptr %result, align 4
// CHECK-NEXT:   %6 = load i32, ptr %i, align 4
// CHECK-NEXT:   %7 = call ptr @"std.builtin.@builtin_test_name"(i32 %6)
// CHECK-NEXT:   store ptr %7, ptr %test_name, align 8
// CHECK-NEXT:   %8 = load i32, ptr %i, align 4
// CHECK-NEXT:   call void @"std.builtin.@builtin_test_run"(ptr sret(%error.struct.void) %struct.ret.tmp, i32 %8)
// CHECK-NEXT:   %9 = getelementptr inbounds %error.struct.void, ptr %struct.ret.tmp, i32 0, i32 1
// CHECK-NEXT:   %10 = load ptr, ptr %9, align 8
// CHECK-NEXT:   %11 = ptrtoint ptr %10 to i64
// CHECK-NEXT:   %ptr.to.bool = icmp ne i64 %11, 0
// CHECK-NEXT:   %select.err = select i1 %ptr.to.bool, ptr %10, ptr @error.str.SUCCESS
// CHECK-NEXT:   store ptr %select.err, ptr %err, align 8
// CHECK-NEXT:   %catch.result = select i1 %ptr.to.bool, i1 true, i1 false
// CHECK-NEXT:   br i1 %catch.result, label %if.true, label %if.exit
// CHECK-NEXT: 
// CHECK-NEXT: while.exit:                                       ; preds = %while.cond
// CHECK-NEXT:   %12 = load i32, ptr %result, align 4
// CHECK-NEXT:   %13 = load i32, ptr %num_test, align 4
// CHECK-NEXT:   %14 = icmp eq i32 %12, %13
// CHECK-NEXT:   br i1 %14, label %if.true1, label %if.false
// CHECK-NEXT: 
// CHECK-NEXT: if.true:                                          ; preds = %while.body
// CHECK-NEXT:   %15 = load i32, ptr %i, align 4
// CHECK-NEXT:   %16 = add i32 %15, 1
// CHECK-NEXT:   %17 = load i32, ptr %num_test, align 4
// CHECK-NEXT:   %18 = load ptr, ptr %test_name, align 8
// CHECK-NEXT:   %19 = load ptr, ptr %err, align 8
// CHECK-NEXT:   %20 = call i32 (ptr, ...) @printf(ptr @global.str.3, i32 %16, i32 %17, ptr %18, ptr %19)
// CHECK-NEXT:   %21 = load i32, ptr %result, align 4
// CHECK-NEXT:   %22 = sub i32 %21, 1
// CHECK-NEXT:   store i32 %22, ptr %result, align 4
// CHECK-NEXT:   br label %if.exit
// CHECK-NEXT: 
// CHECK-NEXT: if.exit:                                          ; preds = %if.true, %while.body
// CHECK-NEXT:   %23 = load i32, ptr %i, align 4
// CHECK-NEXT:   %24 = add i32 %23, 1
// CHECK-NEXT:   store i32 %24, ptr %i, align 4
// CHECK-NEXT:   br label %while.cond
// CHECK-NEXT: 
// CHECK-NEXT: if.true1:                                         ; preds = %while.exit
// CHECK-NEXT:   %25 = load i32, ptr %num_test, align 4
// CHECK-NEXT:   %26 = call i32 (ptr, ...) @printf(ptr @global.str.4, i32 %25)
// CHECK-NEXT:   br label %if.exit2
// CHECK-NEXT: 
// CHECK-NEXT: if.false:                                         ; preds = %while.exit
// CHECK-NEXT:   %27 = load i32, ptr %result, align 4
// CHECK-NEXT:   %28 = load i32, ptr %num_test, align 4
// CHECK-NEXT:   %29 = load i32, ptr %result, align 4
// CHECK-NEXT:   %30 = sub i32 %28, %29
// CHECK-NEXT:   %31 = call i32 (ptr, ...) @printf(ptr @global.str.5, i32 %27, i32 %30)
// CHECK-NEXT:   br label %if.exit2
// CHECK-NEXT: 
// CHECK-NEXT: if.exit2:                                         ; preds = %if.false, %if.true1
// CHECK-NEXT:   ret void
// CHECK-NEXT: }