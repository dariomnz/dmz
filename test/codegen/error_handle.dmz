// RUN: compiler %s -llvm-dump 2>&1 | filecheck %s
// RUN: diff <(compiler %s -run 2>&1) <(echo -n -e "10\nERROR_TWO\nThere was no error\n10\nThere are an error\nNo error 10\nNo safe error 10\n")

const e = error {
    ERROR_ONE,
    ERROR_TWO,
    ERROR_THREE,
};
// CHECK: @error.str.SUCCESS = private constant [8 x i8] c"SUCCESS\00"
// CHECK-NEXT: @error.str.ERROR_ONE = private constant [10 x i8] c"ERROR_ONE\00"
// CHECK-NEXT: @error.str.ERROR_TWO = private constant [10 x i8] c"ERROR_TWO\00"
// CHECK-NEXT: @error.str.ERROR_THREE = private constant [12 x i8] c"ERROR_THREE\00"

fn foo(x:i32) -> i32! {
    if (x == 1){
        return e.ERROR_ONE;
    }
    return x;
}
// CHECK: define void @foo(ptr sret(%error.struct.i32) %ret, i32 %x) {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %0 = icmp eq i32 %x, 1
// CHECK-NEXT:   br i1 %0, label %if.true, label %if.exit
// CHECK-NEXT: 
// CHECK-NEXT: if.true:                                          ; preds = %entry
// CHECK-NEXT:   %1 = getelementptr inbounds %error.struct.i32, ptr %ret, i32 0, i32 1
// CHECK-NEXT:   store ptr @error.str.ERROR_ONE, ptr %1, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: if.exit:                                          ; preds = %entry
// CHECK-NEXT:   store i32 %x, ptr %ret, align 4
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: return:                                           ; preds = %if.exit, %if.true
// CHECK-NEXT:   ret void
// CHECK-NEXT: }

fn bar(x:i32) -> i32! {
    if (x == 2){
        return e.ERROR_TWO;
    }
    return try foo(x);
}
// CHECK: define void @bar(ptr sret(%error.struct.i32) %ret, i32 %x) {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %struct.ret.tmp = alloca %error.struct.i32, align 8
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp, i8 0, i64 16, i1 false)
// CHECK-NEXT:   %0 = icmp eq i32 %x, 2
// CHECK-NEXT:   br i1 %0, label %if.true, label %if.exit
// CHECK-NEXT: 
// CHECK-NEXT: if.true:                                          ; preds = %entry
// CHECK-NEXT:   %1 = getelementptr inbounds %error.struct.i32, ptr %ret, i32 0, i32 1
// CHECK-NEXT:   store ptr @error.str.ERROR_TWO, ptr %1, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: if.exit:                                          ; preds = %entry
// CHECK-NEXT:   call void @foo(ptr sret(%error.struct.i32) %struct.ret.tmp, i32 %x)
// CHECK-NEXT:   %2 = getelementptr inbounds %error.struct.i32, ptr %struct.ret.tmp, i32 0, i32 1
// CHECK-NEXT:   %3 = load ptr, ptr %2, align 8
// CHECK-NEXT:   %4 = ptrtoint ptr %3 to i64
// CHECK-NEXT:   %ptr.to.bool = icmp ne i64 %4, 0
// CHECK-NEXT:   br i1 %ptr.to.bool, label %if.true.try, label %if.exit.try
// CHECK-NEXT: 
// CHECK-NEXT: if.true.try:                                   ; preds = %if.exit
// CHECK-NEXT:   %5 = getelementptr inbounds %error.struct.i32, ptr %ret, i32 0, i32 1
// CHECK-NEXT:   store ptr %3, ptr %5, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.try:                                   ; preds = %if.exit
// CHECK-NEXT:   %6 = getelementptr inbounds %error.struct.i32, ptr %struct.ret.tmp, i32 0, i32 0
// CHECK-NEXT:   %7 = load i32, ptr %6, align 4
// CHECK-NEXT:   store i32 %7, ptr %ret, align 4
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: return:                                           ; preds = %if.exit.try, %if.true.try, %if.true
// CHECK-NEXT:   ret void
// CHECK-NEXT: }

extern fn dprintf(fd:i32, fmt:*u8, ...) -> i32;

fn voiderr(n:i32) -> void! {
    if (n == 0){
        return e.ERROR_THREE;
    }
}

fn main() -> void {
    let result = foo(10);
    let result2 = bar(2);
    dprintf(1, "%d\n", try result);
    let result_e = catch result2;
    dprintf(1, "%s\n", result_e);

    let err = catch result;
    if (err){
        dprintf(1, "%s\n", err);
    } else {
        dprintf(1, "There was no error\n");
    }

    dprintf(1, "%d\n", try result);

    if (catch result){
        dprintf(1, "There are an error\n");
    }
    if (catch foo(1)){
        dprintf(1, "There are an error\n");
    }

    dprintf(1, "No error %d\n", try result);
    dprintf(1, "No safe error %d\n", try foo(10));
}
// CHECK: define void @__builtin_main() {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %result = alloca %error.struct.i32, align 8
// CHECK-NEXT:   %struct.ret.tmp = alloca %error.struct.i32, align 8
// CHECK-NEXT:   %result2 = alloca %error.struct.i32, align 8
// CHECK-NEXT:   %struct.ret.tmp1 = alloca %error.struct.i32, align 8
// CHECK-NEXT:   %result_e = alloca ptr, align 8
// CHECK-NEXT:   %err = alloca ptr, align 8
// CHECK-NEXT:   %struct.ret.tmp9 = alloca %error.struct.i32, align 8
// CHECK-NEXT:   %struct.ret.tmp16 = alloca %error.struct.i32, align 8
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %result, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %result2, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp1, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %result_e, i8 0, i64 8, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %err, i8 0, i64 8, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp9, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp16, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @foo(ptr sret(%error.struct.i32) %struct.ret.tmp, i32 10)
// CHECK-NEXT:   call void @llvm.memcpy.p0.p0.i64(ptr align 8 %result, ptr align 8 %struct.ret.tmp, i64 16, i1 false)
// CHECK-NEXT:   call void @bar(ptr sret(%error.struct.i32) %struct.ret.tmp1, i32 2)
// CHECK-NEXT:   call void @llvm.memcpy.p0.p0.i64(ptr align 8 %result2, ptr align 8 %struct.ret.tmp1, i64 16, i1 false)
// CHECK-NEXT:   %0 = getelementptr inbounds %error.struct.i32, ptr %result, i32 0, i32 1
// CHECK-NEXT:   %1 = load ptr, ptr %0, align 8
// CHECK-NEXT:   %2 = ptrtoint ptr %1 to i64
// CHECK-NEXT:   %ptr.to.bool = icmp ne i64 %2, 0
// CHECK-NEXT:   br i1 %ptr.to.bool, label %if.true.try, label %if.exit.try
// CHECK-NEXT: 
// CHECK-NEXT: if.true.try:                                      ; preds = %entry
// CHECK-NEXT:   %3 = call i32 (ptr, ...) @printf(ptr @0, ptr %1)
// CHECK-NEXT:   call void @llvm.trap()
// CHECK-NEXT:   br label %if.exit.try
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.try:                                      ; preds = %if.true.try, %entry
// CHECK-NEXT:   %4 = getelementptr inbounds %error.struct.i32, ptr %result, i32 0, i32 0
// CHECK-NEXT:   %5 = load i32, ptr %4, align 4
// CHECK-NEXT:   %6 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str, i32 %5)
// CHECK-NEXT:   %7 = getelementptr inbounds %error.struct.i32, ptr %result2, i32 0, i32 1
// CHECK-NEXT:   %8 = load ptr, ptr %7, align 8
// CHECK-NEXT:   store ptr %8, ptr %result_e, align 8
// CHECK-NEXT:   %9 = load ptr, ptr %result_e, align 8
// CHECK-NEXT:   %10 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str.1, ptr %9)
// CHECK-NEXT:   %11 = getelementptr inbounds %error.struct.i32, ptr %result, i32 0, i32 1
// CHECK-NEXT:   %12 = load ptr, ptr %11, align 8
// CHECK-NEXT:   store ptr %12, ptr %err, align 8
// CHECK-NEXT:   %13 = load ptr, ptr %err, align 8
// CHECK-NEXT:   %14 = ptrtoint ptr %13 to i64
// CHECK-NEXT:   %ptr.to.bool2 = icmp ne i64 %14, 0
// CHECK-NEXT:   br i1 %ptr.to.bool2, label %if.true, label %if.false
// CHECK-NEXT: 
// CHECK-NEXT: if.true:                                          ; preds = %if.exit.try
// CHECK-NEXT:   %15 = load ptr, ptr %err, align 8
// CHECK-NEXT:   %16 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str.2, ptr %15)
// CHECK-NEXT:   br label %if.exit
// CHECK-NEXT: 
// CHECK-NEXT: if.false:                                         ; preds = %if.exit.try
// CHECK-NEXT:   %17 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str.3)
// CHECK-NEXT:   br label %if.exit
// CHECK-NEXT: 
// CHECK-NEXT: if.exit:                                          ; preds = %if.false, %if.true
// CHECK-NEXT:   %18 = getelementptr inbounds %error.struct.i32, ptr %result, i32 0, i32 1
// CHECK-NEXT:   %19 = load ptr, ptr %18, align 8
// CHECK-NEXT:   %20 = ptrtoint ptr %19 to i64
// CHECK-NEXT:   %ptr.to.bool3 = icmp ne i64 %20, 0
// CHECK-NEXT:   br i1 %ptr.to.bool3, label %if.true.try4, label %if.exit.try5
// CHECK-NEXT: 
// CHECK-NEXT: if.true.try4:                                     ; preds = %if.exit
// CHECK-NEXT:   %21 = call i32 (ptr, ...) @printf(ptr @1, ptr %19)
// CHECK-NEXT:   call void @llvm.trap()
// CHECK-NEXT:   br label %if.exit.try5
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.try5:                                     ; preds = %if.true.try4, %if.exit
// CHECK-NEXT:   %22 = getelementptr inbounds %error.struct.i32, ptr %result, i32 0, i32 0
// CHECK-NEXT:   %23 = load i32, ptr %22, align 4
// CHECK-NEXT:   %24 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str.4, i32 %23)
// CHECK-NEXT:   %25 = getelementptr inbounds %error.struct.i32, ptr %result, i32 0, i32 1
// CHECK-NEXT:   %26 = load ptr, ptr %25, align 8
// CHECK-NEXT:   %27 = ptrtoint ptr %26 to i64
// CHECK-NEXT:   %ptr.to.bool6 = icmp ne i64 %27, 0
// CHECK-NEXT:   br i1 %ptr.to.bool6, label %if.true7, label %if.exit8
// CHECK-NEXT: 
// CHECK-NEXT: if.true7:                                         ; preds = %if.exit.try5
// CHECK-NEXT:   %28 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str.5)
// CHECK-NEXT:   br label %if.exit8
// CHECK-NEXT: 
// CHECK-NEXT: if.exit8:                                         ; preds = %if.true7, %if.exit.try5
// CHECK-NEXT:   call void @foo(ptr sret(%error.struct.i32) %struct.ret.tmp9, i32 1)
// CHECK-NEXT:   %29 = getelementptr inbounds %error.struct.i32, ptr %struct.ret.tmp9, i32 0, i32 1
// CHECK-NEXT:   %30 = load ptr, ptr %29, align 8
// CHECK-NEXT:   %31 = ptrtoint ptr %30 to i64
// CHECK-NEXT:   %ptr.to.bool10 = icmp ne i64 %31, 0
// CHECK-NEXT:   br i1 %ptr.to.bool10, label %if.true11, label %if.exit12
// CHECK-NEXT: 
// CHECK-NEXT: if.true11:                                        ; preds = %if.exit8
// CHECK-NEXT:   %32 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str.6)
// CHECK-NEXT:   br label %if.exit12
// CHECK-NEXT: 
// CHECK-NEXT: if.exit12:                                        ; preds = %if.true11, %if.exit8
// CHECK-NEXT:   %33 = getelementptr inbounds %error.struct.i32, ptr %result, i32 0, i32 1
// CHECK-NEXT:   %34 = load ptr, ptr %33, align 8
// CHECK-NEXT:   %35 = ptrtoint ptr %34 to i64
// CHECK-NEXT:   %ptr.to.bool13 = icmp ne i64 %35, 0
// CHECK-NEXT:   br i1 %ptr.to.bool13, label %if.true.try14, label %if.exit.try15
// CHECK-NEXT: 
// CHECK-NEXT: if.true.try14:                                    ; preds = %if.exit12
// CHECK-NEXT:   %36 = call i32 (ptr, ...) @printf(ptr @2, ptr %34)
// CHECK-NEXT:   call void @llvm.trap()
// CHECK-NEXT:   br label %if.exit.try15
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.try15:                                    ; preds = %if.true.try14, %if.exit12
// CHECK-NEXT:   %37 = getelementptr inbounds %error.struct.i32, ptr %result, i32 0, i32 0
// CHECK-NEXT:   %38 = load i32, ptr %37, align 4
// CHECK-NEXT:   %39 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str.7, i32 %38)
// CHECK-NEXT:   call void @foo(ptr sret(%error.struct.i32) %struct.ret.tmp16, i32 10)
// CHECK-NEXT:   %40 = getelementptr inbounds %error.struct.i32, ptr %struct.ret.tmp16, i32 0, i32 1
// CHECK-NEXT:   %41 = load ptr, ptr %40, align 8
// CHECK-NEXT:   %42 = ptrtoint ptr %41 to i64
// CHECK-NEXT:   %ptr.to.bool17 = icmp ne i64 %42, 0
// CHECK-NEXT:   br i1 %ptr.to.bool17, label %if.true.try18, label %if.exit.try19
// CHECK-NEXT: 
// CHECK-NEXT: if.true.try18:                                    ; preds = %if.exit.try15
// CHECK-NEXT:   %43 = call i32 (ptr, ...) @printf(ptr @3, ptr %41)
// CHECK-NEXT:   call void @llvm.trap()
// CHECK-NEXT:   br label %if.exit.try19
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.try19:                                    ; preds = %if.true.try18, %if.exit.try15
// CHECK-NEXT:   %44 = getelementptr inbounds %error.struct.i32, ptr %struct.ret.tmp16, i32 0, i32 0
// CHECK-NEXT:   %45 = load i32, ptr %44, align 4
// CHECK-NEXT:   %46 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(i8) @global.str.8, i32 %45)
// CHECK-NEXT:   ret void
// CHECK-NEXT: }