// RUN: compiler %s -llvm-dump 2>&1 | filecheck %s
// RUN: diff <(compiler %s -run) <(echo -n -e "10\nERROR_TWO\nThere was no error\n10\nThere are an error\nNo error 10\nNo safe error 10\n")

err {
    ERROR_ONE,
    ERROR_TWO,
    ERROR_THREE,
}
// CHECK: @err.str.NO_ERROR = private unnamed_addr constant [9 x i8] c"NO_ERROR\00", align 1
// CHECK-NEXT: @err.str.ERROR_ONE = private unnamed_addr constant [10 x i8] c"ERROR_ONE\00", align 1
// CHECK-NEXT: @err.str.ERROR_TWO = private unnamed_addr constant [10 x i8] c"ERROR_TWO\00", align 1
// CHECK-NEXT: @err.str.ERROR_THREE = private unnamed_addr constant [12 x i8] c"ERROR_THREE\00", align 1

fn foo(x:int) -> int? {
    if (x == 1){
        return ERROR_ONE?;
    }
    return x;
}
// CHECK: define void @foo(ptr sret(%err.struct.int) %ret, i32 %x) {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %x1 = alloca i32, align 4
// CHECK-NEXT:   store i32 %x, ptr %x1, align 4
// CHECK-NEXT:   %0 = load i32, ptr %x1, align 4
// CHECK-NEXT:   %1 = icmp eq i32 %0, 1
// CHECK-NEXT:   %bool.to.int = zext i1 %1 to i32
// CHECK-NEXT:   %int.to.bool = icmp ne i32 %bool.to.int, 0
// CHECK-NEXT:   br i1 %int.to.bool, label %if.true, label %if.exit
// CHECK-NEXT: 
// CHECK-NEXT: if.true:                                          ; preds = %entry
// CHECK-NEXT:   %2 = getelementptr inbounds %err.struct.int, ptr %ret, i32 0, i32 1
// CHECK-NEXT:   store ptr @err.str.ERROR_ONE, ptr %2, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: if.exit:                                          ; preds = %entry
// CHECK-NEXT:   %3 = load i32, ptr %x1, align 4
// CHECK-NEXT:   store i32 %3, ptr %ret, align 4
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: return:                                           ; preds = %if.exit, %if.true
// CHECK-NEXT:   ret void
// CHECK-NEXT: }

fn bar(x:int) -> int? {
    if (x == 2){
        return ERROR_TWO?;
    }
    return foo(x)!;
}
// CHECK: define void @bar(ptr sret(%err.struct.int) %ret, i32 %x) {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %x1 = alloca i32, align 4
// CHECK-NEXT:   %struct.ret.tmp = alloca %err.struct.int, align 8
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp, i8 0, i64 16, i1 false)
// CHECK-NEXT:   store i32 %x, ptr %x1, align 4
// CHECK-NEXT:   %0 = load i32, ptr %x1, align 4
// CHECK-NEXT:   %1 = icmp eq i32 %0, 2
// CHECK-NEXT:   %bool.to.int = zext i1 %1 to i32
// CHECK-NEXT:   %int.to.bool = icmp ne i32 %bool.to.int, 0
// CHECK-NEXT:   br i1 %int.to.bool, label %if.true, label %if.exit
// CHECK-NEXT: 
// CHECK-NEXT: if.true:                                          ; preds = %entry
// CHECK-NEXT:   %2 = getelementptr inbounds %err.struct.int, ptr %ret, i32 0, i32 1
// CHECK-NEXT:   store ptr @err.str.ERROR_TWO, ptr %2, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: if.exit:                                          ; preds = %entry
// CHECK-NEXT:   %3 = load i32, ptr %x1, align 4
// CHECK-NEXT:   call void @foo(ptr sret(%err.struct.int) %struct.ret.tmp, i32 %3)
// CHECK-NEXT:   %4 = getelementptr inbounds %err.struct.int, ptr %struct.ret.tmp, i32 0, i32 1
// CHECK-NEXT:   %5 = load ptr, ptr %4, align 8
// CHECK-NEXT:   %6 = ptrtoint ptr %5 to i32
// CHECK-NEXT:   %ptr.to.bool = icmp ne i32 %6, 0
// CHECK-NEXT:   br i1 %ptr.to.bool, label %if.true.unwrap, label %if.exit.unwrap
// CHECK-NEXT: 
// CHECK-NEXT: if.true.unwrap:                                   ; preds = %if.exit
// CHECK-NEXT:   %7 = getelementptr inbounds %err.struct.int, ptr %ret, i32 0, i32 1
// CHECK-NEXT:   store ptr %5, ptr %7, align 8
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.unwrap:                                   ; preds = %if.exit
// CHECK-NEXT:   %8 = getelementptr inbounds %err.struct.int, ptr %struct.ret.tmp, i32 0, i32 0
// CHECK-NEXT:   %9 = load i32, ptr %8, align 4
// CHECK-NEXT:   store i32 %9, ptr %ret, align 4
// CHECK-NEXT:   br label %return
// CHECK-NEXT: 
// CHECK-NEXT: return:                                           ; preds = %if.exit.unwrap, %if.true.unwrap, %if.true
// CHECK-NEXT:   ret void
// CHECK-NEXT: }

extern fn dprintf(fd:int, fmt:&char[], ...) -> int;

fn main() -> void {
    let result = foo(10);
    let result2 = bar(2);
    dprintf(1, &"%d\n", result!);
    catch result_e = result2;
    dprintf(1, &"%s\n", result_e);

    if (catch error = result){
        dprintf(1, &"%s\n", error);
    } else {
        dprintf(1, &"There was no error\n");
    }

    if (try value = result){
        dprintf(1, &"%d\n", value);
    }

    if (catch result){
        dprintf(1, &"There are an error\n");
    }
    if (catch foo(1)){
        dprintf(1, &"There are an error\n");
    }

    dprintf(1, &"No error %d\n", result!);
    dprintf(1, &"No safe error %d\n", foo(10)!);
}
// CHECK: define void @__builtin_main() {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %result = alloca %err.struct.int, align 8
// CHECK-NEXT:   %struct.ret.tmp = alloca %err.struct.int, align 8
// CHECK-NEXT:   %result2 = alloca %err.struct.int, align 8
// CHECK-NEXT:   %struct.ret.tmp1 = alloca %err.struct.int, align 8
// CHECK-NEXT:   %result_e = alloca ptr, align 8
// CHECK-NEXT:   %error = alloca ptr, align 8
// CHECK-NEXT:   %value = alloca i32, align 4
// CHECK-NEXT:   %struct.ret.tmp17 = alloca %err.struct.int, align 8
// CHECK-NEXT:   %struct.ret.tmp26 = alloca %err.struct.int, align 8
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %result, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %result2, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp1, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp17, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %struct.ret.tmp26, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @foo(ptr sret(%err.struct.int) %struct.ret.tmp, i32 10)
// CHECK-NEXT:   call void @llvm.memcpy.p0.p0.i64(ptr align 8 %result, ptr align 8 %struct.ret.tmp, i64 16, i1 false)
// CHECK-NEXT:   call void @bar(ptr sret(%err.struct.int) %struct.ret.tmp1, i32 2)
// CHECK-NEXT:   call void @llvm.memcpy.p0.p0.i64(ptr align 8 %result2, ptr align 8 %struct.ret.tmp1, i64 16, i1 false)
// CHECK-NEXT:   %0 = getelementptr inbounds %err.struct.int, ptr %result, i32 0, i32 1
// CHECK-NEXT:   %1 = load ptr, ptr %0, align 8
// CHECK-NEXT:   %2 = ptrtoint ptr %1 to i32
// CHECK-NEXT:   %ptr.to.bool = icmp ne i32 %2, 0
// CHECK-NEXT:   br i1 %ptr.to.bool, label %if.true.unwrap, label %if.exit.unwrap
// CHECK-NEXT: 
// CHECK-NEXT: if.true.unwrap:                                   ; preds = %entry
// CHECK-NEXT:   call void @llvm.trap()
// CHECK-NEXT:   br label %if.exit.unwrap
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.unwrap:                                   ; preds = %if.true.unwrap, %entry
// CHECK-NEXT:   %3 = getelementptr inbounds %err.struct.int, ptr %result, i32 0, i32 0
// CHECK-NEXT:   %4 = load i32, ptr %3, align 4
// CHECK-NEXT:   %5 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(ptr) @global.str, i32 %4)
// CHECK-NEXT:   %6 = getelementptr inbounds %err.struct.int, ptr %result2, i32 0, i32 1
// CHECK-NEXT:   %7 = load ptr, ptr %6, align 8
// CHECK-NEXT:   %8 = ptrtoint ptr %7 to i32
// CHECK-NEXT:   %ptr.to.bool2 = icmp ne i32 %8, 0
// CHECK-NEXT:   %select.err = select i1 %ptr.to.bool2, ptr %7, ptr @err.str.NO_ERROR
// CHECK-NEXT:   store ptr %select.err, ptr %result_e, align 8
// CHECK-NEXT:   %9 = ptrtoint ptr %7 to i32
// CHECK-NEXT:   %ptr.to.bool3 = icmp ne i32 %9, 0
// CHECK-NEXT:   %catch.result = select i1 %ptr.to.bool3, i32 1, i32 0
// CHECK-NEXT:   %10 = load ptr, ptr %result_e, align 8
// CHECK-NEXT:   %11 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(ptr) @global.str.1, ptr %10)
// CHECK-NEXT:   %12 = getelementptr inbounds %err.struct.int, ptr %result, i32 0, i32 1
// CHECK-NEXT:   %13 = load ptr, ptr %12, align 8
// CHECK-NEXT:   %14 = ptrtoint ptr %13 to i32
// CHECK-NEXT:   %ptr.to.bool4 = icmp ne i32 %14, 0
// CHECK-NEXT:   %select.err5 = select i1 %ptr.to.bool4, ptr %13, ptr @err.str.NO_ERROR
// CHECK-NEXT:   store ptr %select.err5, ptr %error, align 8
// CHECK-NEXT:   %15 = ptrtoint ptr %13 to i32
// CHECK-NEXT:   %ptr.to.bool6 = icmp ne i32 %15, 0
// CHECK-NEXT:   %catch.result7 = select i1 %ptr.to.bool6, i32 1, i32 0
// CHECK-NEXT:   %int.to.bool = icmp ne i32 %catch.result7, 0
// CHECK-NEXT:   br i1 %int.to.bool, label %if.true, label %if.false
// CHECK-NEXT: 
// CHECK-NEXT: if.true:                                          ; preds = %if.exit.unwrap
// CHECK-NEXT:   %16 = load ptr, ptr %error, align 8
// CHECK-NEXT:   %17 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(ptr) @global.str.2, ptr %16)
// CHECK-NEXT:   br label %if.exit
// CHECK-NEXT: 
// CHECK-NEXT: if.false:                                         ; preds = %if.exit.unwrap
// CHECK-NEXT:   %18 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(ptr) @global.str.3)
// CHECK-NEXT:   br label %if.exit
// CHECK-NEXT: 
// CHECK-NEXT: if.exit:                                          ; preds = %if.false, %if.true
// CHECK-NEXT:   %19 = getelementptr inbounds %err.struct.int, ptr %result, i32 0, i32 1
// CHECK-NEXT:   %20 = load ptr, ptr %19, align 8
// CHECK-NEXT:   %21 = getelementptr inbounds %err.struct.int, ptr %result, i32 0, i32 0
// CHECK-NEXT:   %22 = load i32, ptr %21, align 4
// CHECK-NEXT:   store i32 %22, ptr %value, align 4
// CHECK-NEXT:   %23 = ptrtoint ptr %20 to i32
// CHECK-NEXT:   %ptr.to.bool8 = icmp ne i32 %23, 0
// CHECK-NEXT:   %try.result = select i1 %ptr.to.bool8, i32 0, i32 1
// CHECK-NEXT:   %int.to.bool9 = icmp ne i32 %try.result, 0
// CHECK-NEXT:   br i1 %int.to.bool9, label %if.true10, label %if.exit11
// CHECK-NEXT: 
// CHECK-NEXT: if.true10:                                        ; preds = %if.exit
// CHECK-NEXT:   %24 = load i32, ptr %value, align 4
// CHECK-NEXT:   %25 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(ptr) @global.str.4, i32 %24)
// CHECK-NEXT:   br label %if.exit11
// CHECK-NEXT: 
// CHECK-NEXT: if.exit11:                                        ; preds = %if.true10, %if.exit
// CHECK-NEXT:   %26 = getelementptr inbounds %err.struct.int, ptr %result, i32 0, i32 1
// CHECK-NEXT:   %27 = load ptr, ptr %26, align 8
// CHECK-NEXT:   %28 = ptrtoint ptr %27 to i32
// CHECK-NEXT:   %ptr.to.bool12 = icmp ne i32 %28, 0
// CHECK-NEXT:   %catch.result13 = select i1 %ptr.to.bool12, i32 1, i32 0
// CHECK-NEXT:   %int.to.bool14 = icmp ne i32 %catch.result13, 0
// CHECK-NEXT:   br i1 %int.to.bool14, label %if.true15, label %if.exit16
// CHECK-NEXT: 
// CHECK-NEXT: if.true15:                                        ; preds = %if.exit11
// CHECK-NEXT:   %29 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(ptr) @global.str.5)
// CHECK-NEXT:   br label %if.exit16
// CHECK-NEXT: 
// CHECK-NEXT: if.exit16:                                        ; preds = %if.true15, %if.exit11
// CHECK-NEXT:   call void @foo(ptr sret(%err.struct.int) %struct.ret.tmp17, i32 1)
// CHECK-NEXT:   %30 = getelementptr inbounds %err.struct.int, ptr %struct.ret.tmp17, i32 0, i32 1
// CHECK-NEXT:   %31 = load ptr, ptr %30, align 8
// CHECK-NEXT:   %32 = ptrtoint ptr %31 to i32
// CHECK-NEXT:   %ptr.to.bool18 = icmp ne i32 %32, 0
// CHECK-NEXT:   %catch.result19 = select i1 %ptr.to.bool18, i32 1, i32 0
// CHECK-NEXT:   %int.to.bool20 = icmp ne i32 %catch.result19, 0
// CHECK-NEXT:   br i1 %int.to.bool20, label %if.true21, label %if.exit22
// CHECK-NEXT: 
// CHECK-NEXT: if.true21:                                        ; preds = %if.exit16
// CHECK-NEXT:   %33 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(ptr) @global.str.6)
// CHECK-NEXT:   br label %if.exit22
// CHECK-NEXT: 
// CHECK-NEXT: if.exit22:                                        ; preds = %if.true21, %if.exit16
// CHECK-NEXT:   %34 = getelementptr inbounds %err.struct.int, ptr %result, i32 0, i32 1
// CHECK-NEXT:   %35 = load ptr, ptr %34, align 8
// CHECK-NEXT:   %36 = ptrtoint ptr %35 to i32
// CHECK-NEXT:   %ptr.to.bool23 = icmp ne i32 %36, 0
// CHECK-NEXT:   br i1 %ptr.to.bool23, label %if.true.unwrap24, label %if.exit.unwrap25
// CHECK-NEXT: 
// CHECK-NEXT: if.true.unwrap24:                                 ; preds = %if.exit22
// CHECK-NEXT:   call void @llvm.trap()
// CHECK-NEXT:   br label %if.exit.unwrap25
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.unwrap25:                                 ; preds = %if.true.unwrap24, %if.exit22
// CHECK-NEXT:   %37 = getelementptr inbounds %err.struct.int, ptr %result, i32 0, i32 0
// CHECK-NEXT:   %38 = load i32, ptr %37, align 4
// CHECK-NEXT:   %39 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(ptr) @global.str.7, i32 %38)
// CHECK-NEXT:   call void @foo(ptr sret(%err.struct.int) %struct.ret.tmp26, i32 10)
// CHECK-NEXT:   %40 = getelementptr inbounds %err.struct.int, ptr %struct.ret.tmp26, i32 0, i32 1
// CHECK-NEXT:   %41 = load ptr, ptr %40, align 8
// CHECK-NEXT:   %42 = ptrtoint ptr %41 to i32
// CHECK-NEXT:   %ptr.to.bool27 = icmp ne i32 %42, 0
// CHECK-NEXT:   br i1 %ptr.to.bool27, label %if.true.unwrap28, label %if.exit.unwrap29
// CHECK-NEXT: 
// CHECK-NEXT: if.true.unwrap28:                                 ; preds = %if.exit.unwrap25
// CHECK-NEXT:   call void @llvm.trap()
// CHECK-NEXT:   br label %if.exit.unwrap29
// CHECK-NEXT: 
// CHECK-NEXT: if.exit.unwrap29:                                 ; preds = %if.true.unwrap28, %if.exit.unwrap25
// CHECK-NEXT:   %43 = getelementptr inbounds %err.struct.int, ptr %struct.ret.tmp26, i32 0, i32 0
// CHECK-NEXT:   %44 = load i32, ptr %43, align 4
// CHECK-NEXT:   %45 = call i32 (i32, ptr, ...) @dprintf(i32 1, ptr byref(ptr) @global.str.8, i32 %44)
// CHECK-NEXT:   ret void
// CHECK-NEXT: }