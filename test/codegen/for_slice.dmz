// RUN: compiler %s -llvm-dump 2>&1 | filecheck %s
// RUN: diff <(compiler %s -run 2>&1) <(echo -n -e 'slice[0] = 4\nslice[1] = 5\nslice[2] = 6\nslice[3] = 7\nslice[4] = 8\nslice[5] = 9\n4 5 6 7 8 9 \n')

extern fn printf(fmt: *u8, ...) -> i32;
fn main() -> void {
    let str: i32[10] = {0,1,2,3,4,5,6,7,8,9};
    let slice: []i32 = str[4..10];
    for (0..slice.len) |i| {
        printf("slice[%d] = %d\n", i, slice[i]);
    }
    for (slice) |val| {
        printf("%d ", *val);
    }
    printf("\n");
}
// CHECK: define void @__builtin_main() {
// CHECK-NEXT: entry:
// CHECK-NEXT:   %str = alloca [10 x i32], align 4
// CHECK-NEXT:   %"array.i32[10].tmp" = alloca [10 x i32], align 4
// CHECK-NEXT:   %slice = alloca %slice.struct, align 8
// CHECK-NEXT:   %tmp.slice = alloca %slice.struct, align 8
// CHECK-NEXT:   %for.counter = alloca i64, align 8
// CHECK-NEXT:   %for.capture.i = alloca i64, align 8
// CHECK-NEXT:   %for.counter3 = alloca i64, align 8
// CHECK-NEXT:   %for.capture.val = alloca ptr, align 8
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %str, i8 0, i64 40, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %"array.i32[10].tmp", i8 0, i64 40, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %slice, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %tmp.slice, i8 0, i64 16, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %for.counter, i8 0, i64 8, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %for.capture.i, i8 0, i64 8, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %for.counter3, i8 0, i64 8, i1 false)
// CHECK-NEXT:   call void @llvm.memset.inline.p0.i64(ptr align 8 %for.capture.val, i8 0, i64 8, i1 false)
// CHECK-NEXT:   %0 = getelementptr [10 x i32], ptr %"array.i32[10].tmp", i32 0, i32 0
// CHECK-NEXT:   store i32 0, ptr %0, align 4
// CHECK-NEXT:   %1 = getelementptr [10 x i32], ptr %"array.i32[10].tmp", i32 0, i32 1
// CHECK-NEXT:   store i32 1, ptr %1, align 4
// CHECK-NEXT:   %2 = getelementptr [10 x i32], ptr %"array.i32[10].tmp", i32 0, i32 2
// CHECK-NEXT:   store i32 2, ptr %2, align 4
// CHECK-NEXT:   %3 = getelementptr [10 x i32], ptr %"array.i32[10].tmp", i32 0, i32 3
// CHECK-NEXT:   store i32 3, ptr %3, align 4
// CHECK-NEXT:   %4 = getelementptr [10 x i32], ptr %"array.i32[10].tmp", i32 0, i32 4
// CHECK-NEXT:   store i32 4, ptr %4, align 4
// CHECK-NEXT:   %5 = getelementptr [10 x i32], ptr %"array.i32[10].tmp", i32 0, i32 5
// CHECK-NEXT:   store i32 5, ptr %5, align 4
// CHECK-NEXT:   %6 = getelementptr [10 x i32], ptr %"array.i32[10].tmp", i32 0, i32 6
// CHECK-NEXT:   store i32 6, ptr %6, align 4
// CHECK-NEXT:   %7 = getelementptr [10 x i32], ptr %"array.i32[10].tmp", i32 0, i32 7
// CHECK-NEXT:   store i32 7, ptr %7, align 4
// CHECK-NEXT:   %8 = getelementptr [10 x i32], ptr %"array.i32[10].tmp", i32 0, i32 8
// CHECK-NEXT:   store i32 8, ptr %8, align 4
// CHECK-NEXT:   %9 = getelementptr [10 x i32], ptr %"array.i32[10].tmp", i32 0, i32 9
// CHECK-NEXT:   store i32 9, ptr %9, align 4
// CHECK-NEXT:   call void @llvm.memcpy.p0.p0.i64(ptr align 4 %str, ptr align 4 %"array.i32[10].tmp", i64 40, i1 false)
// CHECK-NEXT:   %10 = getelementptr i32, ptr %str, i32 4
// CHECK-NEXT:   %11 = getelementptr inbounds nuw %slice.struct, ptr %tmp.slice, i32 0, i32 0
// CHECK-NEXT:   %12 = getelementptr inbounds nuw %slice.struct, ptr %tmp.slice, i32 0, i32 1
// CHECK-NEXT:   store ptr %10, ptr %11, align 8
// CHECK-NEXT:   store i64 6, ptr %12, align 4
// CHECK-NEXT:   call void @llvm.memcpy.p0.p0.i64(ptr align 8 %slice, ptr align 8 %tmp.slice, i64 16, i1 false)
// CHECK-NEXT:   store i64 0, ptr %for.capture.i, align 4
// CHECK-NEXT:   %13 = getelementptr inbounds nuw %slice.struct, ptr %slice, i32 0, i32 1
// CHECK-NEXT:   %14 = load i64, ptr %13, align 4
// CHECK-NEXT:   %15 = sub i64 %14, 0
// CHECK-NEXT:   br label %for.cond
// CHECK-NEXT: 
// CHECK-NEXT: for.cond:                                         ; preds = %for.increment, %entry
// CHECK-NEXT:   %16 = load i64, ptr %for.counter, align 4
// CHECK-NEXT:   %17 = icmp slt i64 %16, %15
// CHECK-NEXT:   br i1 %17, label %for.body, label %for.exit
// CHECK-NEXT: 
// CHECK-NEXT: for.increment:                                    ; preds = %for.body
// CHECK-NEXT:   %18 = load i64, ptr %for.counter, align 4
// CHECK-NEXT:   %19 = add i64 %18, 1
// CHECK-NEXT:   store i64 %19, ptr %for.counter, align 4
// CHECK-NEXT:   %20 = load i64, ptr %for.capture.i, align 4
// CHECK-NEXT:   %21 = add i64 %20, 1
// CHECK-NEXT:   store i64 %21, ptr %for.capture.i, align 4
// CHECK-NEXT:   br label %for.cond
// CHECK-NEXT: 
// CHECK-NEXT: for.body:                                         ; preds = %for.cond
// CHECK-NEXT:   %22 = load i64, ptr %for.capture.i, align 4
// CHECK-NEXT:   %23 = getelementptr inbounds nuw %slice.struct, ptr %slice, i32 0, i32 0
// CHECK-NEXT:   %24 = load ptr, ptr %23, align 8
// CHECK-NEXT:   %25 = load i64, ptr %for.capture.i, align 4
// CHECK-NEXT:   %26 = getelementptr i32, ptr %24, i64 %25
// CHECK-NEXT:   %27 = load i32, ptr %26, align 4
// CHECK-NEXT:   %28 = call i32 (ptr, ...) @printf(ptr byref(i8) @global.str, i64 %22, i32 %27)
// CHECK-NEXT:   br label %for.increment
// CHECK-NEXT: 
// CHECK-NEXT: for.exit:                                         ; preds = %for.cond
// CHECK-NEXT:   %29 = getelementptr inbounds nuw %slice.struct, ptr %slice, i32 0, i32 0
// CHECK-NEXT:   %30 = load ptr, ptr %29, align 8
// CHECK-NEXT:   store ptr %30, ptr %for.capture.val, align 8
// CHECK-NEXT:   %31 = getelementptr inbounds nuw %slice.struct, ptr %slice, i32 0, i32 1
// CHECK-NEXT:   %32 = load i64, ptr %31, align 4
// CHECK-NEXT:   br label %for.cond1
// CHECK-NEXT: 
// CHECK-NEXT: for.cond1:                                        ; preds = %for.increment2, %for.exit
// CHECK-NEXT:   %33 = load i64, ptr %for.counter3, align 4
// CHECK-NEXT:   %34 = icmp slt i64 %33, %32
// CHECK-NEXT:   br i1 %34, label %for.body4, label %for.exit5
// CHECK-NEXT: 
// CHECK-NEXT: for.increment2:                                   ; preds = %for.body4
// CHECK-NEXT:   %35 = load i64, ptr %for.counter3, align 4
// CHECK-NEXT:   %36 = add i64 %35, 1
// CHECK-NEXT:   store i64 %36, ptr %for.counter3, align 4
// CHECK-NEXT:   %37 = load ptr, ptr %for.capture.val, align 8
// CHECK-NEXT:   %38 = getelementptr i32, ptr %37, i32 1
// CHECK-NEXT:   store ptr %38, ptr %for.capture.val, align 8
// CHECK-NEXT:   br label %for.cond1
// CHECK-NEXT: 
// CHECK-NEXT: for.body4:                                        ; preds = %for.cond1
// CHECK-NEXT:   %39 = load ptr, ptr %for.capture.val, align 8
// CHECK-NEXT:   %40 = load i32, ptr %39, align 4
// CHECK-NEXT:   %41 = call i32 (ptr, ...) @printf(ptr byref(i8) @global.str.1, i32 %40)
// CHECK-NEXT:   br label %for.increment2
// CHECK-NEXT: 
// CHECK-NEXT: for.exit5:                                        ; preds = %for.cond1
// CHECK-NEXT:   %42 = call i32 (ptr, ...) @printf(ptr byref(i8) @global.str.2)
// CHECK-NEXT:   ret void
// CHECK-NEXT: }