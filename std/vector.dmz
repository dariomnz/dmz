const std = import("std");

const vector_error = error {
    IndexOutOfLenght,
    OutOfMemory,
};
pub struct vec<T> {
    buf: []T,
    len: usize,
    alloc: std.mem.Allocator,

    static pub fn init(allocator: std.mem.Allocator) -> @This {
        return @This {
            buf: {},
            len: 0,
            alloc: allocator
        };
    }

    pub fn deinit() -> void {
        .alloc.free(.buf.ptr);
    }

    pub fn add(v: T) -> void! {
        if (.len >= .buf.len) {
            if (.buf.len == 0) {
                .buf.len = 8;
                std.io.printf("Malloc %d\n", .buf.len);
                .buf.ptr = .alloc.malloc(.buf.len * @sizeof(T));
                std.io.printf("Malloc ret\n");
            } else {
                std.io.printf("realloc %d\n", .buf.len);
                .buf.len *= 2;
                std.io.printf("realloc %d\n", .buf.len);
                .buf.ptr = .alloc.realloc(.buf.ptr, .buf.len * @sizeof(T));
                std.io.printf("realloc ret\n");
            }
            if (!.buf.ptr) {
                return vector_error.OutOfMemory;
            }
        }
        .buf[.len] = v;
        .len++;
    }

    pub fn get(index: usize) -> T! {
        if (index > .len) { return vector_error.IndexOutOfLenght; }
        return .buf[index];
    }

    pub fn remove(index: usize) -> void! {
        if (index >= .len) { return vector_error.IndexOutOfLenght; }

        if (index < (.len - 1)) {
            const num_bytes = (.len - index - 1) * @sizeof(T);
            std.mem.memmove(&.buf[index], &.buf[index + 1], num_bytes);
        }

        .len--;
    }

    pub fn size() -> usize {
        return .len;
    }

    pub fn slice() -> []T {
        return .buf[0.. .len];
    }
}