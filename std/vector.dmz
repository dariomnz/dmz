const std = import("std");

const vector_error = error {
    IndexOutOfLenght,
    OutOfMemory,
};
pub struct vec<T> {
    buf: *T,
    len: u64,
    capacity: u64,

    static pub fn init() -> @This {
        return @This {
            buf: null,
            len: 0,
            capacity: 0,
        };
    }

    pub fn deinit() -> void {
        std.mem.free(.buf);
    }

    pub fn add(v: T) -> void! {
        if (.len >= .capacity) {
            if (.capacity == 0) {
                .capacity = 8;
                .buf = std.mem.malloc(.capacity * @sizeof(T));
            } else {
                .capacity = .capacity * 2;
                .buf = std.mem.realloc(.buf, .capacity * @sizeof(T));
            }
            if (!.buf) {
                return vector_error.OutOfMemory;
            }
        }
        .buf[.len] = v;
        .len = .len + 1;
    }

    pub fn get(index: u64) -> T! {
        if (index > .len) { return vector_error.IndexOutOfLenght; }
        return .buf[index];
    }

    pub fn remove(index: u64) -> void! {
        if (index >= .len) { return vector_error.IndexOutOfLenght; }

        if (index < .len - 1) {
            const num_bytes = (.len - index - 1) * @sizeof(T);
            std.mem.memmove(&.buf[index], &.buf[index + 1], num_bytes);
        }

        .len = .len - 1;
    }

    pub fn size() -> u64 {
        return .len;
    }

}