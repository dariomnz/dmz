const std = import("std");

const vector_error = error {
    IndexOutOfLenght,
    OutOfMemory,
};
pub struct vec<T> {
    buf: *T,
    len: u64,
    capacity: u64,
    alloc: std.mem.Allocator,

    static pub fn init(allocator: std.mem.Allocator) -> @This {
        return @This {
            buf: null,
            len: 0,
            capacity: 0,
            alloc: allocator
        };
    }

    pub fn deinit() -> void {
        .alloc.free(.buf);
    }

    pub fn add(v: T) -> void! {
        if (.len >= .capacity) {
            if (.capacity == 0) {
                .capacity = 8;
                .buf = .alloc.malloc(.capacity * @sizeof(T));
            } else {
                .capacity *= 2;
                .buf = .alloc.realloc(.buf, .capacity * @sizeof(T));
            }
            if (!.buf) {
                return vector_error.OutOfMemory;
            }
        }
        .buf[.len] = v;
        .len++;
    }

    pub fn get(index: u64) -> T! {
        if (index > .len) { return vector_error.IndexOutOfLenght; }
        return .buf[index];
    }

    pub fn remove(index: u64) -> void! {
        if (index >= .len) { return vector_error.IndexOutOfLenght; }

        if (index < (.len - 1)) {
            const num_bytes = (.len - index - 1) * @sizeof(T);
            std.mem.memmove(&.buf[index], &.buf[index + 1], num_bytes);
        }

        .len--;
    }

    pub fn size() -> u64 {
        return .len;
    }

}