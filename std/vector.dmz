const std = import("std");

const vector_error = error {
    IndexOutOfLenght,
    OutOfMemory,
};
pub struct vec<T> {
    buf: []T,
    len: usize,
    alloc: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator) -> @This {
        return @This {
            buf: {},
            len: 0,
            alloc: allocator
        };
    }

    pub fn deinit(self: *@This) -> void {
        self.alloc.free(self.buf.ptr);
    }

    pub fn add(self: *@This, v: T) -> !void {
        if (self.len >= self.buf.len) {
            if (self.buf.len == 0) {
                self.buf.len = 8;
                self.buf.ptr = self.alloc.malloc(self.buf.len * @sizeof(T));
            } else {
                self.buf.len *= 2;
                self.buf.ptr = self.alloc.realloc(self.buf.ptr, self.buf.len * @sizeof(T));
            }
            if (!self.buf.ptr) {
                return vector_error.OutOfMemory;
            }
        }
        self.buf[self.len] = v;
        self.len++;
    }

    pub fn get(self: *@This, index: usize) -> !T {
        if (index > self.len) { return vector_error.IndexOutOfLenght; }
        return self.buf[index];
    }

    pub fn remove(self: *@This, index: usize) -> !void {
        if (index >= self.len) { return vector_error.IndexOutOfLenght; }

        if (index < (self.len - 1)) {
            const num_bytes = (self.len - index - 1) * @sizeof(T);
            std.mem.memmove(&self.buf[index], &self.buf[index + 1], num_bytes);
        }

        self.len--;
    }

    pub fn size(self: *@This) -> usize {
        return self.len;
    }

    pub fn slice(self: *@This) -> []T {
        return self.buf[0..self.len];
    }
}