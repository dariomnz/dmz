extern fn malloc(size: u64) -> *void;
extern fn realloc(ptr: *void, size: u64) -> *void;
extern fn free(ptr: *void) -> void;
pub extern fn memmove(dest: *void, src: *void, size:u64) -> *void;
pub extern fn memcpy(dest: *void, src: *void, size:u64) -> *void;

const std = import("std");

pub struct Allocator {
    allocator: *void,
    vtable_malloc: * fn(*void, u64)->*void,
    vtable_realloc: * fn(*void, *void, u64)->*void,
    vtable_free: * fn(*void, *void)->void,

    pub fn malloc(size: u64) -> *void {
        std.io.printf("malloc Allocator %d\n", size);
        return .vtable_malloc(.allocator, size);
    }

    pub fn realloc(ptr: *void, size: u64) -> *void {
        return .vtable_realloc(.allocator, ptr, size);
    }

    pub fn free(ptr: *void) -> void {
        .vtable_free(.allocator, ptr);
    }
}

pub struct libc_allocator {
    allocated: u64,

    static pub fn init() -> @This {
        return @This{
            allocated: 0
        };
    }

    pub fn deinit() -> void! {
        if (.allocated != 0) {
            return error.LeakMemory;
        }
    }

    fn malloc(size: u64) -> *void {
        .allocated++;
        std.io.printf("Malloc %d\n", size);
        return malloc(size);
    }

    fn realloc(ptr: *void, size: u64) -> *void {
        std.io.printf("realloc %d\n", size);
        return realloc(ptr, size);
    }

    fn free(ptr: *void) -> void {
        .allocated--;
        free(ptr);
    }

    pub fn Allocator() -> Allocator {
        return Allocator{
            allocator: .@This,
            vtable_malloc: &.malloc,
            vtable_realloc: &.realloc,
            vtable_free: &.free,
        };
    }
}

// test "leak" {
//     let libc_alloc = libc_allocator.init();
//     let allocator = libc_alloc.Allocator();

//     allocator.malloc(4);

//     try libc_alloc.deinit();
// }