extern fn malloc(size: u64) -> *void;
extern fn realloc(ptr: *void, size: u64) -> *void;
extern fn free(ptr: *void) -> void;
pub extern fn memmove(dest: *void, src: *void, size: u64) -> *void;
pub extern fn memcpy(dest: *void, src: *void, size: u64) -> *void;
pub extern fn strlen(str: *void) -> usize;

pub struct Allocator {
    allocator: *void,
    vtable_malloc: *fn(*void, u64)->*void,
    vtable_realloc: *fn(*void, *void, u64)->*void,
    vtable_free: *fn(*void, *void)->void,

    pub fn malloc(self: *@This, size: u64) -> *void {
        return self.vtable_malloc(self.allocator, size);
    }

    pub fn realloc(self: *@This, ptr: *void, size: u64) -> *void {
        return self.vtable_realloc(self.allocator, ptr, size);
    }

    pub fn free(self: *@This, ptr: *void) -> void {
        self.vtable_free(self.allocator, ptr);
    }
}

pub struct libc_allocator {
    allocated: u64,

    pub fn init() -> @This {
        return @This{
            allocated: 0,
        };
    }

    pub fn deinit(self: *@This) -> !void {
        if (self.allocated != 0) {
            return error.LeakMemory;
        }
    }

    fn malloc(self: *@This, size: u64) -> *void {
        self.allocated++;
        return malloc(size);
    }

    fn realloc(self: *@This, ptr: *void, size: u64) -> *void {
        return realloc(ptr, size);
    }

    fn free(self: *@This, ptr: *void) -> void {
        self.allocated--;
        free(ptr);
    }

    pub fn Allocator(self: *@This) -> Allocator {
        return Allocator{
            allocator: self,
            vtable_malloc: &self.malloc,
            vtable_realloc: &self.realloc,
            vtable_free: &self.free,
        };
    }
}

// test "leak" {
//     let libc_alloc = libc_allocator.init();
//     let allocator = libc_alloc.Allocator();

//     allocator.malloc(4);

//     try libc_alloc.deinit();
// }