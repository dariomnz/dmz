extern fn malloc(size: u64) -> *void;
extern fn realloc(ptr: *void, size: u64) -> *void;
extern fn free(ptr: *void) -> void;
pub extern fn memmove(dest: *void, src: *void, size:u64) -> *void;
pub extern fn memcpy(dest: *void, src: *void, size:u64) -> *void;


struct Allocator_vtable {
    malloc: * fn(*void, u64)->*void,
    realloc: * fn(*void, *void, u64)->*void,
    free: * fn(*void, *void)->void,
}

pub struct Allocator {
    allocator: *void,
    vtable: Allocator_vtable,

    pub fn malloc(size: u64) -> *void {
        return .vtable.malloc(.allocator, size);
    }

    pub fn realloc(ptr: *void, size: u64) -> *void {
        return .vtable.realloc(.allocator, ptr, size);
    }

    pub fn free(ptr: *void) -> void {
        .vtable.free(.allocator, ptr);
    }
}

pub struct libc_allocator {
    allocated: u64,

    static pub fn init() -> @This {
        return @This{
            allocated: 0
        };
    }

    pub fn deinit() -> void! {
        if (.allocated != 0) {
            return error.LeakMemory;
        }
    }

    fn malloc(size: u64) -> *void {
        .allocated = .allocated + 1;
        return malloc(size);
    }

    fn realloc(ptr: *void, size: u64) -> *void {
        return realloc(ptr, size);
    }

    fn free(ptr: *void) -> void {
        .allocated = .allocated - 1;
        free(ptr);
    }

    pub fn Allocator() -> Allocator {
        return Allocator{
            allocator: .@This,
            vtable: Allocator_vtable {
                malloc: &.malloc,
                realloc: &.realloc,
                free: &.free,
            }
        };
    }
}

// test "leak" {
//     let libc_alloc = libc_allocator.init();
//     let allocator = libc_alloc.Allocator();

//     allocator.malloc(4);

//     try libc_alloc.deinit();
// }